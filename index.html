<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>three.jsを用いてBVHファイルを読み込んで3D表示する方法</title>
    <style>
        body {
            color: #fff;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            font-weight: bold;
            background-color: #000;
            margin: 0;
            overflow: hidden;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
        }
        #progressContainer {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }
        #progressBar {
            flex-grow: 1;
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <input type="file" id="fileInput">
        <button id="playButton">再生</button>
        <button id="pauseButton">停止</button>
        <h3>停止中に「.」でコマ送り,「,」でコマ戻り</h3>
    </div>
    
    <div id="progressContainer">
        <span id="currentTime">0:00</span>
        <input type="range" id="progressBar" min="0" max="100" value="0" step="0.1">
        <span id="totalTime">0:00</span>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/BVHLoader.js"></script>
    <script>
        var clock = new THREE.Clock();
        var camera, controls, scene, renderer;
        var mixer, skeletonHelper;
        var jointPoints = [];
        var isPlaying = false;
        var action, animationDuration = 0;
        var frameStep = 1 / 30;

        init();
        animate();

        document.getElementById('fileInput').addEventListener('change', function (event) {
            var file = event.target.files[0];
            if (!file) return;

            var reader = new FileReader();
            reader.onload = function (e) {
                var loader = new THREE.BVHLoader();
                var result = loader.parse(e.target.result);

                if (skeletonHelper) {
                    scene.remove(skeletonHelper);
                    jointPoints.forEach(point => scene.remove(point));
                    jointPoints = [];
                }
                
                skeletonHelper = new THREE.SkeletonHelper(result.skeleton.bones[0]);
                skeletonHelper.skeleton = result.skeleton;
                scene.add(skeletonHelper);
                
                result.skeleton.bones.forEach(bone => {
                    var geometry = new THREE.SphereGeometry(2, 8, 8);
                    var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    var sphere = new THREE.Mesh(geometry, material);
                    scene.add(sphere);
                    jointPoints.push({ sphere, bone });
                });
                
                mixer = new THREE.AnimationMixer(skeletonHelper);
                action = mixer.clipAction(result.clip);
                action.setEffectiveWeight(1.0).play();
                animationDuration = result.clip.duration;
                document.getElementById('progressBar').max = animationDuration;
                document.getElementById('totalTime').textContent = formatTime(animationDuration);
                isPlaying = true;
            };
            reader.readAsText(file);
        });

        document.getElementById('playButton').addEventListener('click', function () {
            if (mixer) {
                mixer.timeScale = 1;
                isPlaying = true;
            }
        });

        document.getElementById('pauseButton').addEventListener('click', function () {
            if (mixer) {
                mixer.timeScale = 0;
                isPlaying = false;
            }
        });

        document.getElementById('progressBar').addEventListener('input', function (event) {
            if (mixer && action) {
                var time = parseFloat(event.target.value);
                action.time = time;
                mixer.update(0);
                document.getElementById('currentTime').textContent = formatTime(time);
                if (!isPlaying) {
                    renderer.render(scene, camera);
                }
            }
        });

        document.addEventListener('keydown', function (event) {
            if (!isPlaying && mixer && action) {
                if (event.key === ',') {
                    action.time = Math.max(0, action.time - frameStep);
                } else if (event.key === '.') {
                    action.time = Math.min(animationDuration, action.time + frameStep);
                }
                mixer.update(0);
                document.getElementById('progressBar').value = action.time;
                renderer.render(scene, camera);
            }
        });

        function formatTime(seconds) {
            var minutes = Math.floor(seconds / 60);
            var secs = Math.floor(seconds % 60);
            return minutes + ":" + (secs < 10 ? "0" : "") + secs;
        }

        function init() {
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 200, 400);

            controls = new THREE.OrbitControls(camera, document.body);
            controls.minDistance = 300;
            controls.maxDistance = 700;

            scene = new THREE.Scene();
            scene.add(new THREE.GridHelper(200, 10));

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0x222222);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            var delta = clock.getDelta();
            if (mixer && isPlaying) {
                mixer.update(delta);
                document.getElementById('progressBar').value = action.time;
                document.getElementById('currentTime').textContent = formatTime(action.time);
            }
            if (skeletonHelper) skeletonHelper.update();
            jointPoints.forEach(({ sphere, bone }) => {
                sphere.position.copy(bone.getWorldPosition(new THREE.Vector3()));
            });
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
